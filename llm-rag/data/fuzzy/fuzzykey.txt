FuzzyKey: Comparing Fuzzy Cryptographic Primitives on Resource-Constrained Devices
Mo Zhang1,4(B), Eduard Marin2, David Oswald1, and Dave Singel´ee3
1 University of Birmingham, Birmingham, UK mxz819@cs.bham.ac.uk, d.f.oswald@bham.ac.uk 2 Telefonica Research, Madrid, Spain eduard.marinfabregas@telefonica.com 3 imec-COSIC, KU Leuven, Leuven, Belgium dave.singelee@esat.kuleuven.be 4 University of Melbourne, Parkville, Australia
Abstract. Implantable medical devices, sensors and wearables arewidely deployed today. However, establishing a secure wireless commu nication channel to these devices is a major challenge, amongst others due to the constraints on energy consumption and the need to obtain immediate access in emergencies. To address this issue, researchers have proposed various key agreement protocols based on the measurement of physiological signals such as a person’s heart signal. At the core of such protocols are fuzzy cryptographic primitives that allow to agree on a shared secret based on several simultaneous, noisy measurements of the same signal. So far, although many fuzzy primitives have been proposed, there is no comprehensive evaluation and comparison yet of the overhead that such methods incur on resource-constrained embedded devices. In this paper, we study the feasibility of six types of fuzzy cryptographic primitives on embedded devices for 128-bit key agreement. We conﬁgureseveral variants for each fuzzy primitive under diﬀerent parameter selec tions and mismatch rates of the physiological signal measurements on an MSP430 microcontroller, and then measure and compare their energyconsumption and communication overhead. The most eﬃcient construc tions consume between 0.021 mJ and 0.198 mJ for the transmitter and between 0.029 mJ and 0.380 mJ for the receiver under diﬀerent mismatch rates. Subsequently, we modify the best performing methods so that they run in constant time to protect against timing side-channel attacks, and observe that these changes only minimally aﬀect resource consumption.Finally, we provide open-source implementations and energy consump tion data of each fuzzy primitive as a reference for real-world designs.
Keywords: Fuzzy commitment · Fuzzy vault · Fuzzy extractor · Physiological signal · Key agreement · Energy consumption
c(cid:2) Springer Nature Switzerland AG 2022 V. Grosso and T. P¨oppelmann (Eds.): CARDIS 2021, LNCS 13173, pp. 289–309, 2022. https://doi.org/10.1007/978-3-030-97348-3_16
M. Zhang et al.
1 Introduction
Healthcare technology is evolving at a rapid pace. Medical sensors are get ting more miniaturised, while being able to measure a broader set of people’s Physiological Signals (PSs) more reliably. New generations of widely-deployedImplantable Medical Devices (IMDs) are considerably lighter and smaller com pared to previous generations. Wearables are extensively used nowadays, alsooften within the context of health monitoring. Multiple wearable and medi cal computing devices can be connected to form a body area network. Besides their application opportunities within the health domain, all these devices have in common that they rely on a wireless interface to communicate with each other or with external devices such as a smartphone. This increased wirelessconnectivity enhances without any doubt the quality of the (remote) health care that can be oﬀered to users. However, in turn, security and privacy are at stake for such medical systems. The medical data that is being monitored on the user is clearly privacy-sensitive. Moreover, the integrity and authenticity of the data, as well as remote updates or commands sent to the devices, have to be protected as well. Unfortunately, researchers have demonstrated that several medical and wearable devices available on the market currently lack security mechanisms [11,22–24,29].
It is therefore evident that cryptographic solutions are needed to secure thewireless interface between these devices. This includes the initial security bootstrap process to establish a secret session key to protect the wireless communica tion link. However, this turns out to be a challenging research problem for variousreasons. First, most of these devices have strict resource constraints, e.g., lim ited memory and computational power. Furthermore, most IMDs are operated by a single non-rechargeable and non-replaceable battery which typically lasts between ﬁve and seven years (depending on the type of device and treatment). Once the battery is drained, the IMD is replaced through a surgical interventionthat can pose risks to patients. Likewise, wearables typically contain small bat teries, e.g., powered by a button cell with approximate a thousand joules. Thus, in such resource-constrained devices every single joule matters. Second, these devices often do not have any input or output interfaces, such as a keypad or a screen. Third, a subset of these medical devices, more particularly IMDs, are not even physically accessible at all, because they are implanted in the patient. Fourth, most of the wireless connections that have to be made with these devices cannot rely on any prior trust relation. This is because these network connections are not static, i.e., the set of external devices one needs to connect to can change quite often. For example, during an emergency situation, the ﬁrst doctor thatis present (who may have never seen the patient before) might have to estab lish a communication link to the patient’s IMD. Due to all these constraints, conventional key distribution and bootstrap techniques are not viable options: key exchanges based on public key cryptography are diﬃcult to manage because they require establishment of a robust Public Key Infrastructure (PKI).
The use of physiological signals (e.g., a signal extracted from the user’s heart beat) has been proposed as an alternative to securely establish a key between two
devices that do not have any prior trust relationship. In contrast to biometrics, where the extracted information is to some extent invariant, PSs are required to be random signals that vary over time. The security of PS-based cryptographic solutions relies on the fact that the user’s PS can only be obtained by makingphysical contact with them (e.g., by touching the skin long enough). A com mon approach to agree on a key is for each of the devices to independently and synchronously take a measurement of a given user’s PS [20,21]. However, the measurements taken by the devices are often not identical but at best rather similar due to inherent noise introduced by the measuring process. To address this limitation, Juels et al. [15,16] and Dodis et al. [10] introduced so-called fuzzy cryptographic primitives, including the fuzzy commitment [16], fuzzy vault [15] and fuzzy extractor [10], which allow two devices to agree a cryptographic key from noisy data.1
1.1 Related Work
Fuzzy cryptographic primitives have become the basis of several PS-based cryp tographic protocols. For example, K Venkatasubramanian et al. [38], Hu et al. [14] and Reshan et al. [4] utilised the fuzzy vault for key agreement based on measurements of InterPulse Intervals (IPIs), i.e., time intervals between R-peaksof Electrocardiogram (ECG) signal. Similarly, Cherukuri et al. proposed a PS based key distribution protocol based on the fuzzy commitment that is used to securely transport a session key between two sensors [7]. Another example is the key agreement protocol by Marin et al. which uses a fuzzy extractor in combination with IPIs [21]. It is worth noting that the security of PS-based key exchange protocols has been exhaustively investigated over the past years. In particular, Calleja et al. [6] and Seepers et al. [32] demonstrated that some PS, such as those extracted from the patient’s heart, might be measured remotely without the need for direct physical touch. Besides, the entropy of the PS itself has been questioned, e.g., although IPI was frequently chosen as the PS used in prior security protocols, Ortiz-Martin et al. [26] challenged that IPIs may not have as much entropy as expected. Furthermore, some PS-based key exchange protocols, such as [7,30], have been proved to be vulnerable to certain attacks
While PS-based solutions have been frequently designed and analysed, little eﬀort has been devoted into studying the feasibility of fuzzy primitives (as the core of such schemes) in resource-constrained systems as well as how to conﬁgure them to optimise performance. This is in contrast to “traditional” cryptographic algorithms, whose eﬃcient implementation on resource-constrained devices has been widely studied, see e.g., [12,25,33].
1 Apart from being used in PS-based key exchange protocols, fuzzy schemes are also used in other areas such as biometrics and Physical Unclonable Functions (PUFs) [3, 5, 9, 10], where traditional cryptographic algorithms are not directly applicable.
M. Zhang et al.
1.2 Contributions
In this paper, we present implementations and evaluations of PS-based 128-bit key agreement based on fuzzy cryptographic primitives on an MSP430, which is a representative low-power microcontroller similar to the one used in commercial IMDs or wearables. Our main contributions are:
1. We implement and optimise six fuzzy cryptographic primitives for PS-based key exchange. Our implementation can be easily ported to diﬀerent platforms. 2. We evaluate and compare the resource consumption (energy consumption andcommunication overhead) of each construction under various parameter set tings both at the transmitter and receiver using an MSP430. We demonstrate that fuzzy primitives are feasible on a resource-constrained embedded device. We show how parameter selection aﬀects the performance and report on the overall best-performing fuzzy primitives under diﬀerent metric spaces. To the best of our knowledge, we are the ﬁrst to provide a systematic evaluations of various fuzzy primitives on resource-constrained devices.
3. We implement countermeasures against timing attacks for the most eﬃcientconstructions, and show that our protected implementations reduce tim ing leakage below the statistical signiﬁcance threshold, while only minimally aﬀecting resource consumption.
Our source code is available under the following link: https://github.com/
MrZMN/FuzzyKey
Paper organisation. The remainder of this paper is organised as follows: inSect. 2, we introduce the mathematical background of fuzzy primitives, com monly used components, and concrete constructions used in this paper. In Sect. 3, we explain our security assumptions and how to instantiate the constructions of fuzzy primitives. We give implementation details in Sect. 4, before evaluating the performance of all fuzzy primitives in Sect. 5. We conclude in Sect. 6.
2 Background
In this section, we describe the mathematical background required for this paper, and discuss several fuzzy cryptographic algorithms. Elementary computations are in GF (2m). In this paper, we consider m ≤ 8 so that computations are fast on constrained embedded devices and most variables ﬁt in one byte. A metric space M is a ﬁnite set. For each M , there is a deﬁnite integer distance dist (m1, m2) between any two elements m1 and m2. The fuzzy primitives discussed in this paper rely on two diﬀerent kinds of metric spaces: (i) Hamming metric space and (ii) set metric space. In a Hamming metric space, M = F (cid:2) for an alphabet F . dist(m1, m2) in M is the Hamming distance, which is the number of positions that m1 diﬀers from m2. For example, for M = {0, 1}3, dist({0, 0, 0}, {1, 1, 1}) = 3. Besides, the number of non-zero elements in m1 is called m1’s Hamming weight. In a set metric space, M contains all s-element subsets of a universe U . dist() in M is the set diﬀerence, which is the size of symmetric diﬀerence
(deﬁned by symdif f (m1, m2) = {x ∈ m1 ∪ m2 | x /∈ m1 ∩ m2}). For example, U = GF (23) and s = 3, dist({0, 1, 2}, {0, 1, 3}) = 2. dist(m1, m2) is an even number when the size of m1 and m2 is the same.
The inputs of the fuzzy primitives working on these two metrics are diﬀerent. For this paper, the input is the physiological value converted from a PS. For Hamming metric methods, the input is a bit string that can be generated by concatenating the bit representations of PSs, such as heart rates, which makes these methods ﬂexible for diﬀerent types of PS. However, because a bit string is consecutive, these methods are sensitive to dislocation and erasure errors on the measurements (e.g., due to peak misdetection when using the heart beat [31]). One bit erasure at the start of a bit string might lead to a signiﬁcant increase in the Hamming distance. Set metric methods alleviate these problems to a certain extent. The input in this case is a set, and even if there are order-diﬀerence or erasure problems on set elements, the set diﬀerence will not vary substantially. However, converting one speciﬁc PS into a set whose elements are randomly distributed in U can be complicated, especially when the size of U is large.
Error Correction Codes. Error Correction Codes (ECCs) are frequently used to achieve error-tolerance in this paper. An ECC comprises encoding and decoding phases. In the encoding phase, the original data is encoded as a codeword, where some form of redundancy is added. When errors appear in the codeword, the decoding phase recovers the original data if the total number of errors is below the error tolerance limit. ECCs are represented by the triple {n, k, t}, where n is the number of symbols of the codeword, k is the number of symbols of the data (k < n), and t is the maximum number of errors that can be corrected in a codeword. The error tolerance is then t/n. We focus on two linear ECCs, namely binary Bose-Chaudhuri-Hocquenghem (BCH) and Reed-Solomon (RS) codes, as already recommended in the ﬁrst papers on fuzzy primitives [10,15,16]. They provide ﬂexible parameter selection as well as eﬃcient encoding and decoding methods. As we will show in the next sections, an eﬃcient ECC can greatly improve the performance of the fuzzy cryptographic algorithms.
2.1 Fuzzy Cryptographic Primitives for PS-Based Key Exchange
We brieﬂy describe all fuzzy cryptographic primitives evaluated in this paper and show their use for PS-based 128-bit key exchange. We distinguish two types: (i) based on Hamming distance (fuzzy commitment, code-oﬀset and syndrome) and (ii) based on set diﬀerence (fuzzy vault, improved Juels-Sudan and Pinsketch). We denote the transmitter and receiver that agree on a cryptographic key as TX and RX, and refer to the physiological values generated by TX and RX as ps and ps(cid:3). Ext←−− denotes extraction of ps or ps(cid:3) from raw PS measurements,
and R←− denotes random number generation. ←−−−−− refers to randomly mixing elements in a set, while calculating the roots of a polynomial is denoted as roots←−−−. We write (0, 1)(cid:2) for an (cid:2)-bit length string and {x, y}s for a set comprising s distinct elements. In all fuzzy cryptographic constructions described below, the ﬁrst step is to extract ps and ps(cid:3), which we will omit in the rest of this section.
M. Zhang et al.
Fig. 1. Fuzzy cryptographic primitives.
In a fuzzy commitment [16], TX generates a random key and encodes it to form a codeword (Fig. 1a). Subsequently, TX masks the codeword by XORing it with ps and then sends the resulting value (denoted by f c) to RX. Upon receiving f c, RX generates codeword(cid:3) by XORing f c with ps(cid:3). Only if the mismatch rate between codeword and codeword(cid:3) is less than the ECC’s error tolerance limit, RX can successfully recover the key previously generated by TX.
The fuzzy vault (Fig. 1b) [15] is designed to “lock” a key using a set of features A. It can be unlocked only by using a set of features B that is suﬃciently similar to A. Concretely, TX generates a key and embeds it in a univariate polynomial p(). Then, TX mixes and sends valid points (x, y), where x is in ps and y = p(x), and invalid points (also known as ‘chaﬀ points’) that do not lie on p(). For each received point, RX veriﬁes whether x is in ps(cid:3), and then performs polynomial reconstruction based on all the matched points. Only if the overlap between ps and ps(cid:3) is suﬃciently large, RX can successfully recover the key.
Both fuzzy commitment and fuzzy vault transport a key using two similar PS measurements. In contrast, fuzzy extractors [10] extract the key from the PS itself. Generally, the mismatches of PS measurements at TX and RX are corrected by sharing “helper data”. Afterwards, both sides use the agreed PS to extract the cryptographic key with a strong random extractor (e.g., a securehash function). We consider four fuzzy extractors in Hamming and set met rics. We omit the key extraction step below as it is the last step shared by all constructions.
The code-oﬀset construction (Fig. 2a) is similar to the fuzzy commitment scheme, but here ps is the secret, while in fuzzy commitment, ps conceals the key. In particular, TX generates a random nonce and encodes it as codeword using the ECC. Then, TX sends ss = codeword⊕ps. RX obtains the codeword(cid:3) = ss ⊕ ps(cid:3) = codeword ⊕ ps ⊕ ps(cid:3) and can decode it to codeword if the mismatch rate is within bounds. Finally, RX recovers ps = codeword ⊕ ss.
The syndrome construction (Fig. 2b) is based on syndrome decoding of an ECC. Concretely, TX and RX regard ps and ps(cid:3) as a codeword and calculate
syndromes syn and syn(cid:3), respectively. TX sends syn to RX, who calculates syn ⊕ syn(cid:3). For mismatch vector mis = ps ⊕ ps(cid:3), syn ⊕ syn(cid:3) is the syndrome of mis, which decodes to mis if the mismatch rate is within bounds. Then, one recovers ps = mis ⊕ ps(cid:3). Compared to code-oﬀset construction, the syndrome is always shorter than the codeword, reducing the communication overhead.
In the improved Juels-Sudan construction (Fig. 2c), TX uses the monic poly w∈ps (x−w) with roots as elements in ps and writes it as the sum nomial p(x) = phigh() + plow(). TX calculates the coeﬃcients of phigh() and sends them to RX. Then, RX generates points (x, y) where x is in ps(cid:3) and y = phigh(x). If ps(cid:3) ≈ ps, most points will also be on plow(), so RX can reconstruct it and obtain ps by ﬁnding roots of p(). Compared with fuzzy vault, the communication overhead is much lower as only some coeﬃcients have to be sent.
The Pinsketch construction (Fig. 2d) is based on an ECC. For universe size u = 2m − 1, a set set can be viewed as a vector {0, 1}u, with 1 at position where x ∈ set and 0 otherwise. In this way, ps and ps(cid:3) are written as two such u-element vectors v, v(cid:3) whose Hamming weight is the set size s. TX and RX calculate the syndromes sstx and ssrx of v and v(cid:3). Afterwords, TX sends sstx to RX, while RX computes syn = sstx ⊕ ssrx. If the mismatch rate is under the error tolerance of the ECC, the syndrome decoding result of syn is the symmetric diﬀerence between sets ps and ps(cid:3), which helps correct the mismatches. Because v and v(cid:3) are binary vectors, BCH codes are particularly suitable [10].
Fig. 2. Fuzzy extractor constructions.
M. Zhang et al.
3 Design Security and Parameter Selection
To provide a systematic comparison and evaluation of fuzzy primitives for PS based key exchange on resource-constrained embedded systems, we make severaldesign decisions: Taking into account the limits on energy consumption and com putational resources in a body-area network scenario and the fact that keys areoften short-lived, we limit ourselves to 128-bit keys. Furthermore, we only con sider key exchange between two devices. We note that subsequent protocol steps, such as key conﬁrmation step to ensure that TX and RX derive the same 128-bit key, are independent of the underlying fuzzy primitive and hence do not considerthose steps. We also note that fuzzy primitives are only responsible for correct ing the mismatches of the PS, i.e., we do not consider errors on the wireless channel, and assume that the underlying wireless protocol includes appropriate error detection and correction measures.
Adversary Model. We consider a strong adversary who knows all details about the used fuzzy primitives and has full access to the communication channelbetween TX and RX. The adversary can (i) perform passive attacks by eaves dropping on the communication and exploiting information leakage from it. For example, if ps and ps(cid:3) in a fuzzy commitment are low-entropy, the adversary can statistically analyse their distribution and thus compromise the security [27]. Alternatively, correlation-based methods that leverage the correlation between communication data over multiple key exchange sessions can be used [17]. On the other hand, the adversary can also (ii) carry out active attacks, i.e., act as Man-In-The-Middle (MITM) or replay old sessions. Finally, the adversary can also observe and exploit secret-dependent timing leakage e.g., the precise time between two protocol messages, both in passive and active attacks.
We assume that the measured PS cannot be modelled or predicted and cannot be remotely obtained. The latter implies that adversary can be in proximity to the user but cannot touch him directly or indirectly (because this would allow the adversary to measure the signal), nor being able to compromise a deviceworn by the user to measure the PS. In the research community, this touch-toaccess access control model is widely accepted as it oﬀers a reasonable trade oﬀ between security and availability [24,30]. Although the security may rely on user awareness to some extent, this model ensures high availability in emergency situations where fast establishment of a secure channel to the IMD is vital. For this reason, we leave physical side-channel and other attacks with direct access (such as fault injection) out of the adversary model, as in this case, the adversary can equally measure the PS directly for key recovery. We also do not consider Denial-of-Service (DoS) attacks such as jamming or battery depletion attacks.
Countermeasures Against Passive Attacks. The underlying security of the fuzzy commitment against oﬄine attacks depends on the entropy of the bit strings ps and ps(cid:3) extracted from PS as these are used to conceal the key (by XOR) while being transported. The security of fuzzy vault relies on the fact that the adversary cannot distinguish between valid and chaﬀ points, and hence is unable
to reconstruct p(). For a fuzzy vault scheme with parameters g, b and d (cf.
Fig. 1b), the adversary would need an average of to reveal p() (assuming that Berlekamp-Welch decoding is used). Therefore, the number of chaﬀ points needs to be suﬃciently large.
For fuzzy extractors, the security depends on the entropy of the PS itself as the key is directly extracted from the PS. Due to the leakage of helper data, there will be an amount of entropy loss on PS in each construction. For code-oﬀset and syndrome constructions, the entropy loss is (n − k) · f , where n, k come from the underlying (n, k, t) ECC, and f is the number of bits constituting each symbol. The entropy loss is t · log2 u for the improved Juels-Sudan construction, and is t · log2(u + 1) for the Pinsketch construction, where u is the universe size and t is the maximum set diﬀerence between ps and ps(cid:3). Note that the above represent worst case entropy loss values [10]. Some of them were also proven to be overly pessimistic [9]. To ensure security, we regard the worst-case values as the actual entropy loss in this paper. Because we only focus on 128-bit key agreement, if the remaining entropy of PS (the agreed PS before input to the strong extractor) is ≥128 bit, the fuzzy extractor is considered secure.
For correlation-based attacks, note that in the case of PS-based key exchange, the PS has to vary over time and the exchanged key (generated randomly by the device or extracted from the PS) is short-lived and diﬀerent in each session [20], unlike scenarios based on non-variable materials, e.g., biometrics or PUFs. This means that correlation attacks are prevented by the nature of the application.
Countermeasures Against Active and Timing Attacks. Due to the varying key,replay attacks are by design prevented. Other active attacks (such as guessing based ones) require the adversary to break the fuzzy primitive “online” within a single protocol session [4,18], otherwise, they at most result in failure of the key exchange and are detected by subsequent key conﬁrmation. They can thus be prevented by generating a secret with substantially high entropy. Active attacksbased on accurate measurement or modelling of the underlying PS [6] are out side our adversary model. Timing attacks can be generically prevented using constant-time implementations techniques, which we further discuss in Sect. 4.
Assumptions on Physiological Signal. The selection of the PS (e.g., IPI) and its quality as an entropy source, although an important issue, are out of the scope of this paper. However, we would like to stress that the quality of PS only aﬀects the total measurement time, e.g., a lower quality of the entropy source means longer measurements. In order to generate the input for the fuzzy primitives, a set of pre-processing methods (e.g., quantisation and coding [26]) is applied to the raw PS measurements. However, this is out of the scope of this paper.
Assumptions on Fuzzy Primitive Input. The inputs of fuzzy primitives (i.e., ps and ps(cid:3) in Sect. 2.1) are extracted from some PS which is measured by two devices simultaneously. There are several factors that aﬀect the similarity of ps and ps(cid:3), e.g., the type of PS, the measurement accuracy of the sensor, and the signal processing method. To evaluate and compare diﬀerent fuzzy primitives, it
M. Zhang et al.
is necessary to consider pre-deﬁned mismatch rates (i.e., percentage of diﬀerentbits/set elements) between ps and ps(cid:3), which reﬂect the characteristics of diﬀer ent kinds of scenarios. In this paper, we consider three mismatch thresholds of 2%, 5% and 10%. While the authors of [39,40] reported that the mismatch rate for heart rate measurements is typically below 5%, we note that other PSs might have slightly higher mismatch thresholds. We also note that unlike BCH codes, RS codes are multi-bit-symbol based. Thus, for RS code variants, the abovethresholds indicate the percentage of diﬀerent symbols rather than bits. Addi tionally, one should note that the average bit error rate (i.e., the possibility that each bit diﬀers for two bitstrings) may be more broadly used on the Hamming metric in other application scenarios, thus, we also provide this information for each variant in Table 2 (with a maximum tolerable failure rate of 10−6). This maximum average bit rate that can be tolerated needs to be considered when selecting the most appropriate error correcting code.
Here, we assume that ps and ps(cid:3) are (cid:2)-bit strings that are random and uni formly distributed for Hamming metric methods, or sets containing s distinct elements that are uniformly distributed in a universe U for set metric methods. This assumption is only made for fairly comparing diﬀerent fuzzy primitives;both fuzzy commitment and fuzzy vault naturally require the input to be uniformly randomly distributed to ensure security.2 Additionally, if the fuzzy prim itive inputs are not uniformly distributed, it is hard to quantify the entropy levelof the PS and establish a uniﬁed mismatch rate threshold. Under this assump tion, the initial entropy of the PS is (cid:2) for Hamming metric fuzzy extractors, while for set metric fuzzy extractors, it is log2
with u the size of U .
Parameter Selection. The mismatch rate between ps and ps(cid:3) directly determines the error tolerance requirement of the fuzzy primitives. For Hamming metric methods, the error tolerance is the same as that of the underlying ECC (i.e., t/n for an (n, k, t) code). For example, (50, 44, 1) and (20, 15, 1) BCH codes are suitable when the maximum mismatch rate is 2% and 5%, respectively. However, RS codes cannot provide exact 2%, 5% and 10% error tolerance because of their inherent structure. Therefore, we selected several RS constructions with error tolerance within 2% + the pre-deﬁned mismatch rate thresholds. For example, the error tolerance of a (31, 29, 1) RS code is 3.23%. As mentioned in Sect. 2, all codes stay within the ﬁeld GF (28). For set metric methods with (u, s, t) structure, where u is the universe size, s the set size and t the maximum tolerable set diﬀerence between ps and ps(cid:3), the error tolerance is t/2s.
For each fuzzy primitive, there can be multiple feasible parameter choices under the same mismatch rate, e.g., using diﬀerent conﬁgurations of ECCs mayachieve the same error tolerance. The diﬀerence between them is that the repe tition count might be diﬀerent: Assume the total repetition count is r and the number of secret bits distributed in each iteration is i, we need to ensure that r · i ≥ 128 to achieve 128-bit security. This way, RX concatenates the secret
2 However, this requirement can be alleviated with the combination of a Password Authenticated Key Exchange (PAKE), as shown in [18]. Note that fuzzy extractors can still be securely used even if the inputs are not uniformly distributed.
bits it receives in each iteration to form the 128-bit key. The security of subse quent/parallel execution based on linear codes has been proven in [9]. Note that i is the length of the key distributed per iteration for fuzzy commitment and fuzzy vault, but the remaining entropy of PS for fuzzy extractors. Consider a fuzzy commitment that is based on (50, 44, 1) and (200, 168, 4) BCH codes (both handle mismatch ≤2%) as an example. In order to distribute a 128-bit key, the former variant needs to be executed three times (3 · 44 > 128), while the latter only needs to be executed once. Although more iterations may be required, small parameter choices (e.g., an ECC with a small block size) almost always mean less computation and hence less energy consumption. Therefore, we test diﬀerent variants under the same mismatch threshold. A variant with larger parameter choice is considered only if it reduces the number of required iterations. Besides, under each mismatch rate, the variants used by diﬀerent fuzzy primitives in each metric are the same, thus help with the performance comparison.
Note that for Hamming metric methods, the number of feasible variantsdepends on the number of underlying ECCs that achieve the pre-deﬁned mis match thresholds. We give all feasible variants for Hamming metric in Table 2. For set metric methods, there are more possible (u, s, t) variants because (i) theuniverse size u can vary depending on how a PS is converted to a set and (ii) mul tiple s and t combinations can achieve the same error tolerance. In this paper, we use u = 255, which is the maximum universe size for the Pinsketch construction on GF (28). We deﬁne three variants (255, 50, 2), (255, 20, 2) and (255, 10, 2) for 2%, 5%, and 10% mismatch rate thresholds. These variants are provided for reference only, and one could devise more appropriate variants for set metrics with speciﬁc mappings from PS to set. Finally, the fuzzy vault construction over GF (28) is insecure, because the number of chaﬀ points is ≤28. However, for our performance evaluation in Sect. 5, we limit ourselves to GF (28), and note that the system can be easily extended to larger ﬁelds (e.g., GF (216)).
4 Implementation
We implemented, ran, and measured all algorithms on a TI MSP430FR5969LaunchPad development board [35]. This board comprises a 16-bit microprocessor with 2 kB volatile SRAM and 64 kB permanent FRAM, which is represen tative for low-power body area network devices (including e.g., IMDs). We also alternatively used an MSP430FR5994 development board [36] with 8 kB SRAM for certain variants that require more resources, and indicate this in Table 2. For development, we used TI’s Code Composer Studio as it provides integrated functionality for on-device energy consumption measurement.
Implementation of the Strong Extractor. Considering many embedded micro controllers, including the MSP430 used in this paper, feature a hardware AES accelerator, we opted to use a block cipher-based hash function, with AES as theunderlying cipher. We selected the Hirose construction [13] for the strong extractor in our implementation. Hirose is a double-block-length hash with MerkleDamg˚ard structure. We measured the average energy consumption of each invo cation of the Hirose compression function on MSP430FR5969 to be 1.42 µJ.
M. Zhang et al.
Depending on the availability of a fast hardware/software implementation, other hash functions such as SHA256 can be used instead of Hirose.
Software Development and Energy Measurement. We implemented all algorithms in plain C and mainly relied on standard C libraries so that our implementation can be easily ported to other platforms. For random number generation and hardware-accelerated AES, we used TI’s driver APIs. The tested average energy consumption of generating 16 bytes when using TI’s random number generator API is 2.5 µJ. Certain components can be implemented in diﬀerent ways. For example, there are a variety of algorithms for ECCs. We chose commonly used, eﬃcient algorithms: for BCH and RS encoding, we used standard cyclic code encoding, and for decoding we used the Berlekamp decoding method [2,19]. For polynomial reconstruction, we used the Berlekamp-Welch algorithm.
We carried out the energy consumption measurement using TI energyTrace tool. This functionality allows to take accurate on-device energy measurement from the Code Composer Studio IDE. For each measurement, we averaged the energy consumption value over 100 executions of the respective algorithm. To test the error correction ability of the fuzzy primitives, we artiﬁcially added the maximum tolerable number of mismatches on the PS in the code, and then measured the corresponding energy consumption. We used TI Ultra Low Power Advisor tool to refactor our code and minimise energy consumption. Overall, we found that these optimisations reduced the energy consumption ≤10%.
Estimation of Communication Energy Cost. The energy consumption of a protocol between multiple devices comprises two components: (i) the energy consumption of computations; and (ii) the energy consumption of wireless communi cation. In this paper, we only measure the energy consumption of computation, and model the cost of wireless communication based on the number of bits to be transmitted and received. In particular, in Sect. 5, we use the experimental results of [25] for a TelosB [8], a wireless sensor node based on a 16-bit MSP430microcontroller and a CC2420 transceiver to illustrate the impact of commu nication overhead on overall energy consumption. Their results show that for 75 kbps data rate and −5 dBm transmit power, the average energy required to transmit one bit of eﬀective data is 0.72 µJ, and the energy required to receive this bit is 0.81 µJ.
We acknowledge that a simplistic “energy-per-bit” model may be inadequate e.g., when using packet-based protocols such as Bluetooth Low Energy (BLE)3, where the constant overheads due to the frame structure and other steps (e.g., wakeup and preparation) can be substantial. Therefore, we also provide the number of payload bits for each variant in Table 2, which can be fed into a more appropriate energy consumption model for a speciﬁc wireless protocol (e.g., informed by measurements as reported in [34]). We note that many widely used protocols support payloads large enough to accommodate all our variants in one packet (e.g., 246 bytes for BLE). This minimizes the impact of the frame
3 BLE is already being used in commercial IMDs e.g., Medtronic Azure pacemakers [1].
structure, thus, when considering such protocols, the diﬀerent implementations can be compared purely based on their computational energy cost.
Defenses Against Timing Side Channels. We implemented countermeasures against timing-based side-channel attacks on the best-performing variants (i.e., fuzzy primitives with lowest total energy consumption under diﬀerent mismatch thresholds, cf. Table 4). We found that non-constant execution time mainly arises in the ECC encoding/decoding processes through various conditional branchesdepending on a value being negative. To address this, we replaced all such conditional branches with Boolean operators, and used other constant-time imple mentation techniques, such as constant-time modulo reduction (based on Barrett reduction) and constant-time sorting.
Table 1. Eﬀects of timing side-channel defenses on timing leakage (measured by Welch’s t-test) and energy consumption.
Fuzzy primitive
t-value Energy (mJ)
Unprotected
t-value Energy (mJ) t-value Energy (mJ)
Unprotected t-value Energy (mJ)
Syndrome extractor (31,29,1)RS
Syndrome extractor (31,27,2)RS
Syndrome extractor (63,49,7)RS
Pinsketch extractor
(255,50,2)
Pinsketch extractor
(255,20,2)
Pinsketch extractor
(255,10,2)
We empirically veriﬁed the eﬀects of implementing the above countermeasures, including the eﬀect on timing leakage and energy consumption (commu nication overhead included). We used dudect [28] to evaluate the timing leakage of the TX and RX implementations running on the MSP430FR5969. The resultsare given in Table 1. The timing leakage of a program is evaluated by Welch’s t test in dudect. For each TX and RX implementation, the t-value in Table 1 was computed using 10,000 timing measurements. For a t-value ≤10, dudect regards the timing leakage as insigniﬁcant given the number of timing measurements.
It is evident that the baseline implementations exhibit strong timing leakage,while the protected variants signiﬁcantly reduce the leakage below the constant time threshold of the t-test in dudect. Besides, the energy consumption is not signiﬁcantly increased for the protected variants. In fact, in some cases the energy consumption even decreases because of the use of Barrett reduction, which replaces the costly modulo operation otherwise implemented through division.
5 Performance Evaluation
We implemented 22 variants of fuzzy primitives in total for the Hamming metric and three for the set metric. For each variant, we measured its computational energy consumption and estimated the communication cost at both TX and RX sides, and give the input size (extracted from the PS) required to achieve 128-bit security. Table 3 shows the main building blocks used by each fuzzy primitive.
Table 2. Evaluation of Hamming and set metric methods
Max. average bit error rate
# iterations
PS data (bit)
(50, 44, 1) BCH (100, 86, 2) BCH (200, 168, 4) BCH (31, 29, 1) RS (20, 15, 1) BCH (40, 28, 2) BCH (60, 42, 3) BCH (80, 52, 4) BCH (100, 65, 5) BCH (220, 136, 11) BCH (15, 13, 1) RS (31, 27, 2) RS (10, 6, 1) BCH (20, 10, 2) BCH (30, 15, 3) BCH (40, 16, 4) BCH (50, 23, 5) BCH (60, 27, 6) BCH (90, 34, 9) BCH (120, 43, 12) BCH (210, 70, 21) BCH (63, 49, 7) RS
Fuzzy vault
Fuzzy commitment
Code-oﬀset construction
Syndrome construction
Improved Juels–Sudan construction
Pinsketch construction
# iterations
(255, 50, 2) (255, 20, 2) (255, 10, 2)
# iterations
# iterations
Table 2 shows the detailed measurement results for all considered fuzzy primitive instantiations in both the Hamming and set metric. We include the following characteristics of each variant: error tolerance, maximum average bit error rate, required number of iterations to achieve 128-bit security, computational energy cost at TX/RX (excluding communication cost), communication overhead (in bits transmitted/received), and required number of bits extracted from the PS. ∗ indicates implementation on MSP430FR5994 due to memory requirements.
In the following, we focus on the evaluation and comparison of selected vari ants. We include full, detailed results for all variants in Table 2. As mentioned, we base our estimation of communication costs on the values of 0.72 µJ per bit for TX and 0.81 µJ for RX [25], but also provide the number of exchanged payload bits for use with other models to estimate communication energy.
5.1 Hamming Metric Constructions
The minimum number of input bits derived from the PS is given as n · f · r, where n is the codeword length of the chosen ECC, f is the number of bits constituting a symbol, and r is the number of repetitions (i.e., how many iterations of the primitive are required for 128-bit security). Depending on the speciﬁc variant, between 150 and 420 PS-derived bits are required (cf. Table 2). However, as we focus on the fuzzy primitive itself, rather than the conversion from PS to the algorithm input, we provide these values for reference only and to guide developer decisions in speciﬁc situations.
Table 3. Main building blocks of fuzzy primitives for TX and RX.
Find poly.
Gen. points
Fuzzy commitment Fuzzy vault Code-oﬀset extractor Syndrome extractor Improved JS extractor Pinsketch extractor
Reconstruct
Gen. points
Fuzzy commitment Fuzzy vault Code-oﬀset extractor Syndrome extractor Improved JS extractor Pinsketch extractor
Computation Costs. Fig. 3 shows the energy cost of the Hamming metric fuzzy primitives. For each mismatch threshold, we show four variants of each fuzzy primitive and note that they are adequate to indicate the overall trend. At TX side, we observe that the fuzzy commitment consumes the least energy. The cost
M. Zhang et al.
of the code-oﬀset extractor is generally slightly higher than the fuzzy commit ment under diﬀerent mismatch rates. This result is in line with our expectations,because the code-oﬀset extractor can be seen as a fuzzy commitment with addi tional invocation of a strong extractor. The syndrome fuzzy extractor involves the most energy-intensive computations. This is because syndrome generationfor BCH and RS codes is an expensive operation that involves repeatedly eval uating p(x) given x, which requires a number of iterative operations.
At RX side, we note that the energy consumption of the fuzzy commitment is also the smallest. The diﬀerence in computational energy consumption between the code-oﬀset and syndrome extractors is often small because both extractors share several building blocks. Note that, even if the syndrome extractor has an extra “syndrome generation” block compared to the code-oﬀset extractor (cf. Table 3), the actual execution of these constructions is equivalent.
Regarding ECC choice, the RS code performs substantially better than BCH for mismatch rates below 5%. However, for 10% mismatch, the chosen RS code is worse than the best BCH variant. However, note that e.g., the (63, 49, 7) RS instance can accommodate up to 343-bit distribution per iteration for the fuzzy commitment, while we only require 128 bits, which is not optimal if only considering computational energy consumption.
Fig. 3. Energy consumption of Hamming metric primitives.
Combined Computation and Communication Cost. When we also take the estimated communication costs into account, the syndrome fuzzy extractor out performs the other two variants most of the time. For both fuzzy commitment and code-oﬀset construction, the communication overhead is determined by the codeword length n of the chosen ECC and the number of required repetitions. For example, consider the (50, 44, 1) BCH variant in Table 2. In this case, the communication overhead is 50 · 3 bits, because the variant needs to be executed three times to establish a 128-bit key. In contrast, the communication overhead for the syndrome extractor depends on the syndrome length and the number of repetitions. The length of the syndrome is 2 · t · m for BCH and RS codes, where m comes from GF (2m) underlying the ECC [19]. An obvious advantage is that
the syndrome is always shorter than the codeword. Considering the previousexample, TX would only need to transmit 12 · 3 bits for the syndrome extrac tor. Overall, the variants with lowest combined computation and communication cost under each mismatch rate are shown in Table 4. The syndrome extractor has variants with the lowest total energy consumption in all conditions.
Table 4. Fuzzy primitives with lowest total energy cost on the Hamming metric (Syn drome extractor) and set metric (Pinsketch extractor).
Mismatch rate
Fuzzy primitive
Total energy at TX (mJ) Total energy at RX (mJ)
Syndrome extractor
(31,29,1) RS
Syndrome extractor
(31,27,2) RS
Syndrome extractor
(63,49,7) RS
Pinsketch extractor
(255,50,2)
Pinsketch extractor
(255,20,2)
Pinsketch extractor
(255,10,2)
5.2 Set Metric Constructions
The required number of derived bits for set metric methods is s · f · r, where s is the set size, f is the number of bits constituting a set element, and r is the number of repetitions. Set metric constructions require input sizes from 160 to 400 bits (cf. Table 2), which is similar to the Hamming metric variants.
Computation Costs. Figure 4 shows the energy consumption of all considered set metric methods (cf. Table 2 for the underlying data). At TX, we observe that the fuzzy vault consumes substantially more energy than the other two methods. This is likely because TX of the fuzzy vault has to generate and shuﬄe a large amount of points (mostly chaﬀ points). The TX energy cost of the Pinsketch fuzzy extractor is slightly below improved Juels-Sudan. According to Table 3, the diﬀerence in energy consumption is due to the diﬀerence between syndrome generation (note that this is not the same as the standard syndrome calculation of BCH and RS code) and the polynomial coeﬃcient ﬁnding.
On the RX side, we ﬁnd that the Pinsketch construction has the lowest energy consumption for mismatch rates below 5%, and has slightly higher consumption than fuzzy vault for 10% mismatch. The improved Juels-Sudan fuzzy extractor is always the most expensive construction under all mismatch rates, likely due to the required polynomial root ﬁnding process. We further observe that the energy consumption of this method and the fuzzy vault decrease signiﬁcantly when the mismatch rate threshold increases. This is expected because both methods rely on the same complex polynomial reconstruction for mismatch correction. Thisinvolves operations on s × s matrices (s is the set size). Hence, polynomial recon struction is eﬃcient for small sets (i.e., under higher mismatch threshold), but as the set size increases, the computational complexity increases quadratically.
M. Zhang et al.
Fig. 4. Energy consumption of set metric primitives.
Combined Computation and Communication Cost. The number of transmitted bits for the fuzzy vault is np · lp · r, where np is the total number of points (valid and chaﬀ points), lp is the length of each point, and r is the repetition count. For our universe size of 255, np = 255 and lp = 16 bits (each coordinate is one byte). In contrast, the transmission size for improved Juels-Sudan and Pinsketch fuzzy extractors is t · f · r, where t is the maximum tolerable set diﬀerence between sets and f is the number of bits constituting a set element (in our constructions f = 8). Hence, the communication cost of the fuzzy vault is much higher compared to improved Juels-Sudan and Pinsketch. The overall best set metric variants for each mismatch threshold are shown in Table 4. The Pinsketch fuzzy extractor performs best in terms of combined computation and communication cost in all cases. The improved Juels-Sudan has extremely high computation cost in RX, while the fuzzy vault incurs substantial communication overhead. Considering that secure implementation of fuzzy vault requires operations over GF (216) and transmits more points, it is likely that costs would further grow in practice.
5.3 Common Observations and Comparison with Curve25519
We observed certain common tendencies for all fuzzy primitives: for each vari ant, the computation energy consumption for RX is generally higher than for TX. Conversely, the communication cost is roughly the same for TX and RX.This observation is relevant when assigning TX/RX roles in more complex pro tocols; e.g., a low-power IMD can act as TX if the goal is to minimise energyconsumption. In addition, the energy consumption of variants with larger param eter (e.g., larger BCH code) shows an increase both for TX and RX, even though the number of required repetitions decreases.
We compared the energy cost of our best-performing variants with Curve25519, one of the most eﬃcient elliptic curve-based key exchange schemes for embedded systems. As reported in [12], one full execution of Curve25519 on MSP430FR5969 costs about 0.012 mJ (0.404 mJ if communication energy is estimated as in this paper). Thus, our methods are comparable in terms of total energy consumption. Moreover, fuzzy primitives provide security guarantees
beyond a public-key scheme such as Curve25519: they can defend against MITM attacks (without certiﬁcate infrastructure) and guarantee that RX and TX are in physical proximity.
6 Conclusion
In this paper, we systematically and fairly evaluate the performance of fuzzy cryptographic primitives for PS-based key exchange under controlled conditions on a resource-constrained MSP430 microcontroller. We show how diﬀerent fuzzyprimitives can be securely applied to derive a 128-bit key from joint measurements of a PS, and provide implementations of each of these primitives in multi ple variants. To our knowledge, we are the ﬁrst to compare the computation and communication energy consumption of diﬀerent fuzzy primitives for a variety of parameter choices. Among all considered fuzzy primitives, we ﬁnd that Syndrome and Pinsketch fuzzy extractors overall oﬀer the lowest energy consumption in Hamming and set metric spaces.
This indicates that fuzzy commitment and fuzzy vault used in previous PS based key exchange solutions [4,7,14,37,38] are not optimal on constrained devices. Instead, Syndrome/Pinsketch fuzzy extractors may be preferable, with the added advantage that they neither require random number generation, which can be costly on embedded systems, nor uniformly randomly distributed inputs derived from a PS. These constructions consume between 0.021 mJ and 0.198 mJ for TX and between 0.029 mJ and 0.380 mJ for RX, including computational and communication energy. This demonstrates that PS-based key exchange methods using fuzzy primitives are feasible for a resource-constrained device, even if keys are relatively frequently exchanged. We also observe that ECCs with smaller parameter choices in fuzzy primitives have generally better performance, even if more repetitions are required. However, this might come at the cost of having more strict constraints on the maximum average bit error rate of a PS. Our work serves as a reference when applying fuzzy primitives for body-area networks and medical devices, and for other use cases such as biometrics or PUFs.
Acknowledgements. This work is funded in part by the European Union’s Horizon 2020 Research and innovation program under grant agreement No. 826284 (ProTego), the FWO-SBO project SPITE, and by the Engineering and Physical Sciences Research Council (EPSRC) under grant EP/R012598/1. Mo Zhang is funded by the Priestley PhD Scholarship programme. The ECC decoding methods were based in part on the source code of Simon Rockliﬀ [2].
References
1. Medtronic Azure pacing system. https://europe.medtronic.com/xd-en/healthcare
professionals/products/cardiac-rhythm/pacemakers/azure.html
2. Simon Rockliﬀ’s Reed-Solomon encoder/decoder. http://www.eccpage.com/rs.c 3. Abidin, A., Argones R´ua, E., Peeters, R.: Uncoupling biometrics from templates
for secure and privacy-preserving authentication. In: ACM SACMAT (2017)
M. Zhang et al.
4. Al Reshan, M., Liu, H., Hu, C., Yu, J.: MBPSKA: multi-biometric and physiological signal-based key agreement for body area networks. IEEE Access 7, 78484–78502
5. Billeb, S., Rathgeb, C., Reininger, H., Kasper, K., Busch, C.: Biometric template protection for speaker recognition based on universal background models. IET Biometrics 4(2), 116–126 (2015)
6. Calleja, A., Peris-Lopez, P., Tapiador, J.E.: Electrical heart signals can be mon itored from the moon: security implications for IPI-based protocols. In: WISTP, pp. 36–51 (2015)
7. Cherukuri, S., Venkatasubramanian, K.K., Gupta, S.K.S.: BioSec: a biometric based approach for securing communication in wireless networks of biosensors implanted in the human body. In: ICPP, pp. 432–439 (2003)
8. Crossbow Technology Inc.: TelosB Mote Platform datasheet, Rev. B, https://www.
willow.co.uk/TelosB Datasheet.pdf
9. Delvaux, J., Gu, D., Schellekens, D., Verbauwhede, I.: Helper data algorithms for PUF-based key generation: overview and analysis. IEEE TCAD 34(6), 889–902
10. Dodis, Y., Ostrovsky, R., Reyzin, L., Smith, A.: Fuzzy extractors: how to generate strong keys from biometrics and other noisy data. SIAM J. Comput. 38(1), 97–139
11. Halperin, D., Heydt-Benjamin, T.S., Fu, K., Kohno, T., Maisel, W.H.: Security and privacy for implantable medical devices. IEEE Pervasive Comput. Spec. Issue Implantable Electron. 7, 30–39 (2008)
12. Hinterw¨alder, G., Moradi, A., Hutter, M., Schwabe, P., Paar, C.: Full-size high security ECC implementation on MSP430 microcontrollers. In: Aranha, D.F., Menezes, A. (eds.) LATINCRYPT 2014. LNCS, vol. 8895, pp. 31–47. Springer, Cham (2015). https://doi.org/10.1007/978-3-319-16295-9 2
13. Hirose, S.: Some plausible constructions of double-block-length hash functions. In:
FSE, pp. 210–225 (2006)
14. Hu, C., Cheng, X., Zhang, F., Wu, D., Liao, X., Chen, D.: OPFKA: secure and eﬃcient ordered-physiological-feature-based key agreement for wireless body area networks. In: INFOCOM (2013)
15. Juels, A., Sudan, M.: A fuzzy vault scheme. Des. Codes Crypt. 38(2), 237–257
16. Juels, A., Wattenberg, M.: A fuzzy commitment scheme. In: ACM CCS (1999) 17. Kholmatov, A., Yanikoglu, B.: Realization of correlation attack against the fuzzyvault scheme. In: Security, Forensics, Steganography, and Watermarking of Multi media Contents X, vol. 6819, p. 68190O. SPIE (2008)
18. Li, X., Zeng, Q., Luo, L., Luo, T.: T2Pair: secure and usable pairing for heteroge
neous IoT devices. In: ACM CCS, pp. 309–323 (2020)
19. Lin, S., Costello, D.J.: Error Control Coding, vol. 2. Prentice Hall (2001) 20. Marin, E., Argones R´ua, E., Singel´ee, D., Preneel, B.: On the diﬃculty of using patient’s physiological signals in cryptographic protocols. In: ACM SACMAT, pp. 113–122 (2019)
21. Marin, E., Mustafa, M.A., Singel´ee, D., Preneel, B.: A privacy-preserving remotehealthcare system oﬀering end-to-end security. In: Mitton, N., Loscri, V., Moura dian, A. (eds.) ADHOC-NOW 2016. LNCS, vol. 9724, pp. 237–250. Springer, Cham (2016). https://doi.org/10.1007/978-3-319-40509-4 17
22. Marin, E., Singel´ee, D., Garcia, F.D., Chothia, T., Willems, R., Preneel, B.: On the (in)security of the latest generation implantable cardiac deﬁbrillators and how to secure them. In: ACSAC, pp. 226–236 (2016)
23. Marin, E., Singel´ee, D., Yang, B., Verbauwhede, I., Preneel, B.: On the feasibility
of cryptography for a wireless insulin pump system. In: CODASPY (2016)
24. Marin, E., et al.: Securing wireless neurostimulators. In: CODASPY, pp. 287–298
25. de Meulenaer, G., Gosset, F., Standaert, F., Pereira, O.: On the energy cost of communication and cryptography in wireless sensors networks. In: IEEE WiMob, pp. 580–585 (2008)
26. Ortiz Martin, L., Picazo-Sanchez, P., Peris-Lopez, P., Tapiador, J.: Heartbeats do not make good pseudo-random number generators: an analysis of the randomness of inter-pulse intervals. Entropy 20, 94 (2018)
27. Rathgeb, C., Uhl, A.: Statistical attack against fuzzy commitment scheme. IET
Biometrics 1(2), 94–104 (2012)
28. Reparaz, O., Balasch, J., Verbauwhede, I.: Dude, is my code constant time? In:
DATE, pp. 1697–1702. IEEE (2017)
29. Reverberi, L., Oswald, D.: Breaking (and ﬁxing) a widely used continuous glucose
monitoring system. In: USENIX WOOT (2017)
30. Rostami, M., Juels, A., Koushanfar, F.: Heart-to-Heart (H2H): authentication for
implanted medical devices. In: ACM CCS, pp. 1099–1112 (2013)
31. Seepers, R.M., Strydis, C., Peris-Lopez, P., Sourdis, I., Zeeuw, C.I.D.: Peak mis detection in heart-beat-based security: characterization and tolerance. In: EMBC, pp. 5401–5405 (2014)
32. Seepers, R.M., Wang, W., de Haan, G., Sourdis, I., Strydis, C.: Attacks on heartbeat-based security using remote photoplethysmography. IEEE J-BHI 22(3), 714–721 (2018)
33. Singel´ee, D., Seys, S., Batina, L., Verbauwhede, I.: The energy budget for wireless
security: extended version. IACR Cryptol. ePrint Arch. 2015, 1029 (2015) 34. TI: AN092: Measuring Bluetooth Low Energy Power Consumption (2012) 35. TI: MSP430FR596x, MSP430FR594x Mixed-Signal Microcontrollers datasheet
(2012). rev. G. https://www.ti.com/lit/gpn/msp430fr5969
36. TI: MSP430FR599x, MSP430FR596x Mixed-Signal Microcontrollers datasheet
(2016). rev. C. https://www.ti.com/lit/gpn/msp430fr5994
37. Venkatasubramanian, K.K., Banerjee, A., Gupta, S.: Plethysmogram-based secure inter-sensor communication in body area networks. In: IEEE MILCOM (2008) 38. Venkatasubramanian, K.K., Banerjee, A., Gupta, S.K.S.: PSKA: usable and secure key agreement scheme for body area networks. IEEE T-ITB 14(1), 60–68 (2010) 39. Venkatasubramanian, K.K., Gupta, S.K.S.: Physiological value-based eﬃcient usable security solutions for body sensor networks. ACM TOSN 6(4), 1–36 (2010) 40. Xu, F., Qin, Z., Tan, C.C., Wang, B., Li, Q.: IMDGuard: securing implantable medical devices with the external wearable guardian. In: IEEE INFOCOM (2011)
